<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>HatsuEcho</title><link>https://HatsuEcho.github.io</link><description>(⁠눈⁠‸⁠눈⁠)</description><copyright>HatsuEcho</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://HatsuEcho.github.io</link></image><lastBuildDate>Fri, 15 Aug 2025 15:52:51 +0000</lastBuildDate><managingEditor>HatsuEcho</managingEditor><ttl>60</ttl><webMaster>HatsuEcho</webMaster><item><title>[DRG BP Modding] 五. 在游戏中修改名字</title><link>https://HatsuEcho.github.io/post/%5BDRG%20BP%20Modding%5D%20-wu-.%20-zai-you-xi-zhong-xiu-gai-ming-zi.html</link><description>这次要做的 Mod 会相对有趣一些, 但同时比较麻烦, 需要使用一些特殊手段, 请务必严格按照教程来做.
前面的步骤就不解释了, 如果你从前面几章看下来, 基本都知道要做什么.

![Image](https://github.com/user-attachments/assets/e7cf4344-3ccb-48dd-8777-a2c69d8af7ee)

![Image](https://github.com/user-attachments/assets/1c1e092d-3bd9-4f7c-8fde-efb963e1a56f)

打开蓝图, 把父类改成玩家控制器.

![Image](https://github.com/user-attachments/assets/959bb825-95eb-455c-b902-fc77330c73ed)

随便放置一个节点, 比如这个.

![Image](https://github.com/user-attachments/assets/b2536f3c-3be9-4174-a2ed-a8bb6b6bbbf3)

然后随便找个地方右键新建关卡.

![Image](https://github.com/user-attachments/assets/2332114d-2940-4015-91ee-a1bf8639a421)

在左上角编辑, 项目设置, 左边选择地图和模式, 将地图设为刚才新建的关卡.

![Image](https://github.com/user-attachments/assets/9e5e75d7-46cf-4cf9-8d23-8d2ef7662cd3)

然后重启一下引擎.
打开关卡蓝图.

![Image](https://github.com/user-attachments/assets/e730d3d1-ba96-4e38-9670-7e95816c813b)

放置该节点.

![Image](https://github.com/user-attachments/assets/7ab9543b-e41e-41a5-9c17-a59e184e590f)

复制主蓝图的引用.

![Image](https://github.com/user-attachments/assets/2dc58cf3-ea9e-410f-87af-c6f324727b14)

把长引用粘贴到节点中, 并且去掉前面和后面多余的的内容, 看起来像这样.

![Image](https://github.com/user-attachments/assets/620011cc-e121-4986-a54a-fe8f10d20566)

回到主蓝图, 右键复制这个节点, 然后粘贴到记事本中.

![Image](https://github.com/user-attachments/assets/462ea549-9846-47c5-b4fb-da9f525c0bac)

在该节点后面继续添加 `:EventGraph.` .

![Image](https://github.com/user-attachments/assets/0458ac7c-0059-44c1-9c7f-121c9e20f3b4)

然后在记事本中找到这个节点在编辑器中的名称, 复制粘贴到节点后方.

![Image](https://github.com/user-attachments/assets/8d457d11-2532-4652-885f-af4de2ed5211)

![Image](https://github.com/user-attachments/assets/9dbef1d8-22d5-42fc-95c8-700d85ddb35d)

然后依次放置这些节点.

![Image](https://github.com/user-attachments/assets/f4d52d98-6307-4bd1-a6f5-b2b1b0c5eeaf)

![Image](https://github.com/user-attachments/assets/479b6b9c-4e55-4c97-a5c7-77f2123055f4)

接着在文件夹中新建蓝图函数库.

![Image](https://github.com/user-attachments/assets/8a137cb3-4840-45c0-9173-59834fccd8cf)

![Image](https://github.com/user-attachments/assets/512063a7-d306-401e-acc2-9680cba2a5a7)

在函数库里新建这两个函数, 名字必须跟图中一样, 然后不要点保存.

![Image](https://github.com/user-attachments/assets/21ed31db-0d30-4fb3-bb6b-f8ff52026f6a)

到关卡蓝图中调用这两个函数.

![Image](https://github.com/user-attachments/assets/d0359fb1-4970-459e-82ad-f58462256937)

保存好所有内容, 但是不要保存刚才新建的函数库, 然后关闭引擎重新打开.

![Image](https://github.com/user-attachments/assets/2958d3e0-3d77-4779-b1be-4e4895ccaafe)

忽略错误信息, 打开关卡蓝图, 可以看到, 这两个被人为隐藏的函数通过这种方法诱导出来了.
对这个函数填上变量值.

![Image](https://github.com/user-attachments/assets/cad0e3d8-7d02-42b9-a81b-36837ccebf6a)

然后新建一个变量, 类型为命中结果.

![Image](https://github.com/user-attachments/assets/262c3e8e-9447-4b43-a4b8-6bb1b80a6b3e)

选中该变量, Ctrl + C 复制粘贴到记事本中.

![Image](https://github.com/user-attachments/assets/07de774b-debf-481c-96d9-7bf06c4226d2)

找到图中这一个字段, 将 `HitResult` 修改为 `MemberReference` .

![Image](https://github.com/user-attachments/assets/7682cf4a-8177-4894-bb71-7240b98daa9a)

![Image](https://github.com/user-attachments/assets/b31437b5-f458-4750-8a13-d4db0959ed9c)

然后把刚才粘贴的这一整段复制, 回到编辑器, 粘贴变量.

![Image](https://github.com/user-attachments/assets/090c432a-ce38-45b2-909d-72109f4686c4)

![Image](https://github.com/user-attachments/assets/9f490e22-72a0-4562-87cc-b20e8b2b71d7)

继续复制该变量的默认值, 粘贴到记事本.
找到这一段, 填上 `ServerChangeName` .

![Image](https://github.com/user-attachments/assets/04c88249-0e65-4f7e-b953-abbb181c008c)

![Image](https://github.com/user-attachments/assets/6e98f5e8-8ffa-4db7-b299-c65265bba1f7)

复制主蓝图的引用, 替换这一段, 并掐头去尾, 在尾部加上 `_C` .

![Image](https://github.com/user-attachments/assets/70c9dbdf-d771-4099-bdc4-2d31e59f4cf9)

![Image](https://github.com/user-attachments/assets/34286f23-6c3b-4817-b8da-fb7461ec4be1)

![Image](https://github.com/user-attachments/assets/39093d0f-a338-41b5-9089-5b106d91e479)

接着复制这一段, 粘贴到变量的默认值.

![Image](https://github.com/user-attachments/assets/142b7d8b-9059-441f-ab18-fd636d2508a2)

把节点连接上, 编译保存.

![Image](https://github.com/user-attachments/assets/2aa8aa65-e1a8-4ca4-b8d4-a6c1ab2b446d)

然后运行该关卡, 等待1-2秒后关闭.

![Image](https://github.com/user-attachments/assets/8080ce84-6b52-42d5-8797-0bb2cf5f6159)

打开主蓝图, 右键刷新节点, 可以看到原本的节点已经被我们篡改成这个被隐藏起来的节点, 但我们并不能通过编译, 因为该节点被人为设置成不允许调用.

![Image](https://github.com/user-attachments/assets/c72fc17a-e141-4860-bf92-0f2d82eb4d41)

我们先断开这个节点的连接.
回到关卡蓝图, 连上第二个函数, 并填写好变量信息.

![Image](https://github.com/user-attachments/assets/ad052a36-4474-412a-bbec-afa9e4657694)

然后再运行一次关卡, 退出, 这时可以看到, 节点已经成功通过编译了!

![Image](https://github.com/user-attachments/assets/e19cc79b-d788-4ce0-8c62-a68ee530fcf0)

还没完, 记得把主蓝图的父类改回actor.
改回actor后, 就可以开始写你的 Mod 了.

![Image](https://github.com/user-attachments/assets/42c72a55-f3b3-4324-a978-532848d73906)

![Image](https://github.com/user-attachments/assets/d881c13a-94dc-4c6b-881c-73bc183e5015)

最后记得删掉关卡蓝图的内容.

![Image](https://github.com/user-attachments/assets/fc4cb8f3-b787-4ec6-811f-94a9ef182664)。</description><guid isPermaLink="true">https://HatsuEcho.github.io/post/%5BDRG%20BP%20Modding%5D%20-wu-.%20-zai-you-xi-zhong-xiu-gai-ming-zi.html</guid><pubDate>Fri, 15 Aug 2025 15:52:20 +0000</pubDate></item><item><title>[DRG BP Modding] 四. 敌人数量计数器</title><link>https://HatsuEcho.github.io/post/%5BDRG%20BP%20Modding%5D%20-si-.%20-di-ren-shu-liang-ji-shu-qi.html</link><description>这一节我们将继续深入, 制作一个敌人数量计数器.
先说下核心思路, 我们需要找到场景中所有属于敌方的角色, 然后按照蜂拥敌人, 静止敌人, 常规敌人来分类, 最后将每一个分类的敌人数量显示在屏幕上.
那么现在开始动手.
按照惯例, 创建文件夹, 以及所需的存档, 用户界面等.

![Image](https://github.com/user-attachments/assets/383234f6-58b1-4bda-8f5e-9dafc768dd34)

![Image](https://github.com/user-attachments/assets/484cfabf-6547-4eed-bdf3-b5fb8658b16f)

在存档中创建布尔值变量, 这些步骤与上一章基本相同.

![Image](https://github.com/user-attachments/assets/f6752473-80a8-478c-bc2d-1fff91527d65)

然后在计数器界面中设置好样式.
别忘了把对应的三个文本块设成变量.

![Image](https://github.com/user-attachments/assets/18c9d97d-3546-4a42-997b-d66d66e184c5)

![Image](https://github.com/user-attachments/assets/53dc79ab-8da8-4bb6-a978-b1c412bd0661)

设置界面也一样, 确保勾选框是变量即可.

![Image](https://github.com/user-attachments/assets/13e38222-b676-4a9e-a6b1-75147f805948)

![Image](https://github.com/user-attachments/assets/d8699e03-e6ae-4117-a4c9-548fa9e4a9a3)

现在开始创建主要蓝图 Actor.
按照惯例去掉可被伤害, 编写好准备阶段的逻辑.
这里的1秒延迟主要是防止某些偶然情况小部件过早添加到视口导致无法显示在屏幕上.

![Image](https://github.com/user-attachments/assets/140a32e4-bcdd-4aa8-abf5-a59c132e4034)

![Image](https://github.com/user-attachments/assets/c433ccf7-4e04-4f33-bead-343890ec95d6)

![Image](https://github.com/user-attachments/assets/8fa06297-5b7d-4c36-852d-572059295143)

设置界面的输入别忘了添加.

![Image](https://github.com/user-attachments/assets/036a00b0-705e-4405-9342-3ca985e4b020)

![Image](https://github.com/user-attachments/assets/3523afc9-1a5b-44f9-af40-b0a5b0571ede)

初始化步骤完成之后, 到设置界面实现勾选框的功能.

![Image](https://github.com/user-attachments/assets/82fe6b19-1b1a-4297-a8d1-337b9e19bb14)

之后到主蓝图回应这个事件.

![Image](https://github.com/user-attachments/assets/3cd623df-2692-4e31-926d-f1b9d4a875c3)

然后现在开始编写这个 Mod 的主要功能了, 创建一个函数, 使用定时器去获取场景的敌人并且将数量更新到小部件上.

![Image](https://github.com/user-attachments/assets/b66af62a-1ab5-426e-a400-621cb2c3631b)

![Image](https://github.com/user-attachments/assets/89c72007-bef1-4339-9e91-350c6a87c7bc)

这里我选择获取场景中所有含有敌对标签的 FSDPawn 类, 创建一个 FSDPawn 类的集合, 将获取到符合条件的敌人都放进去.

![Image](https://github.com/user-attachments/assets/29429033-7044-448f-97a7-47207f7cf420)

创建一个函数, 按下图添加输入, 这一步将用于获取蜂拥类敌人.

![Image](https://github.com/user-attachments/assets/c61be40d-f058-4b77-a2fc-c528b6c63141)

![Image](https://github.com/user-attachments/assets/104d5147-44ea-4d06-ba2e-be234babd1ea)

在该函数中, 对输入的敌人输出到一个数组, 使用 For Each Loop 节点遍历这个数组.
我们首先需要知道, 游戏中绝大多数可移动的敌人, 都在 EnemyDeepPathfinderCharacter 类下, 而静止类敌人处于 EnemyPawn 类下, 所以需要将符合条件的筛出来.

![Image](https://github.com/user-attachments/assets/f9500e31-9641-4918-a17c-6763ea7842f2)

用分支节点判断每个敌人是否含有敌对和蜂拥标签, 这样就能筛选出所有的蜂拥类敌人.

![Image](https://github.com/user-attachments/assets/2c03eb40-c574-4db2-a213-1398128d84ae)

创建一个映射, 将所有不在键集中的敌人都添加进去.

![Image](https://github.com/user-attachments/assets/4a5a5753-fc48-4832-b79c-fe5021844a90)

![Image](https://github.com/user-attachments/assets/b4622865-bbe4-40e9-af79-1903d11dc0cf)

但还没完, 在这个过程中, 也会有很多敌人死亡, 或者被系统刷掉, 对于这些已经无效的敌人我们要及时移除.
在数组遍历完成后, 继续检查映射中的敌人, 通过健康组件判断是否已经死亡或者无效, 然后从映射中移除.

![Image](https://github.com/user-attachments/assets/f57dc97f-d14f-457a-ac75-b7e1401db3a5)

剩下的静止类敌人和常规敌人也是一样的思路.

![Image](https://github.com/user-attachments/assets/31627cd5-4c10-4cf8-b398-d27831b93df2)

![Image](https://github.com/user-attachments/assets/e983277f-ff7c-4834-98b2-27fb337083fb)

![Image](https://github.com/user-attachments/assets/3a62f5e7-6b54-4f2b-a9e6-6330967c4222)

等到具体的敌人之后, 我们只需要分别获取每个映射的长度就能得到敌人的数量, 这里再创建一个函数来处理.

![Image](https://github.com/user-attachments/assets/711d4cda-a6ad-4fe4-8580-c4def34420e4)

按照下图将长度转换成字符, 经过处理后设置为小部件对应的文本内容.

![Image](https://github.com/user-attachments/assets/0722c4d9-2a98-42d2-a75b-aaedaa50a492)

剩下的步骤都是一样的.

![Image](https://github.com/user-attachments/assets/0715b78c-0301-4cbc-a405-4f6d6f1902c9)

到这里 Mod 的功能已经全部完成了, 像以往一样添加 ModHub 的接口就行.

![Image](https://github.com/user-attachments/assets/6e584a22-7916-4db5-92f4-1e883c3fd5d6)

![Image](https://github.com/user-attachments/assets/2b2b12b5-34eb-42e8-86e0-2e6ee2ba8a0f)

![Image](https://github.com/user-attachments/assets/2297a8f9-377d-45b5-90be-238f9526c66a)

以及保存存档.

![Image](https://github.com/user-attachments/assets/6456b10a-b227-412d-9bc3-2b91a30be154)

检查无误后就可以打包了.

![Image](https://github.com/user-attachments/assets/0d995c13-9278-40e0-b06a-fd9435e7520a)

进游戏看看效果.

![Image](https://github.com/user-attachments/assets/68ccaba1-4142-4445-a577-bddc6fc750e1)。</description><guid isPermaLink="true">https://HatsuEcho.github.io/post/%5BDRG%20BP%20Modding%5D%20-si-.%20-di-ren-shu-liang-ji-shu-qi.html</guid><pubDate>Wed, 13 Aug 2025 07:07:56 +0000</pubDate></item><item><title>[DRG BP Modding] 三. 制作一个任务计时器</title><link>https://HatsuEcho.github.io/post/%5BDRG%20BP%20Modding%5D%20-san-.%20-zhi-zuo-yi-ge-ren-wu-ji-shi-qi.html</link><description>在个人文件夹下, 创建任务计时器文件夹.

![Image](https://github.com/user-attachments/assets/22fd6d6e-3d73-4236-b73c-62d22d6a05c5)

进入该文件夹, 右键创建用户控件蓝图.

![Image](https://github.com/user-attachments/assets/7e73e362-d7fa-4360-83ea-c0b74cf13aa7)

![Image](https://github.com/user-attachments/assets/ce236148-487f-43c6-883a-dfeb287ce5e1)

打开控件蓝图, 在左侧将文本块拖入画布面板中

![Image](https://github.com/user-attachments/assets/ac98721d-dcd0-4db6-bc21-6481952a87cd)

锚点设置为顶部居中

![Image](https://github.com/user-attachments/assets/df2f7b19-626f-4cd0-b4bb-447e4744f49a)

并按照图中调整属性

![Image](https://github.com/user-attachments/assets/aeeef444-44eb-4bfa-bbeb-dddbea3f0b9a)

字体尺寸可以根据情况适当调整.
接着修改文本块的命名, 设置为变量.

![Image](https://github.com/user-attachments/assets/dc9241ca-bbaa-4faf-87da-bf34e3acaada)

回到文件夹, 再创建一个用户控件蓝图, 用于该 Mod 的设置界面.

![Image](https://github.com/user-attachments/assets/8c6ef87a-b375-4408-a2d7-834abcfe8f65)

设置界面可随意设计, 只需确保你拥有勾选框, 并且设为变量.

![Image](https://github.com/user-attachments/assets/cf9f5451-0de0-497d-a979-4fcdfb5b524f)

![Image](https://github.com/user-attachments/assets/905a9f65-9043-416d-9c6a-74ff1b44f0d8)

在文件夹内创建一个蓝图类, 类选择SaveGame.

![Image](https://github.com/user-attachments/assets/d1a59e0b-d3d2-4cc0-9b0c-38e5472d0b2d)

这会作为我们 Mod 的存档, 可以将需要保存的参数和设置保存到硬盘.
打开存档蓝图, 创建一个布尔值变量.

![Image](https://github.com/user-attachments/assets/550faf96-b71c-42a6-934e-13c40cdd086d)

然后回到文件夹, 接下来创建 Mod 的主要蓝图, 类型为 Actor.

![Image](https://github.com/user-attachments/assets/a2f9abff-908c-4ecd-be12-6622e15f9e41)

关闭启用 Tick 和可被伤害.

![Image](https://github.com/user-attachments/assets/d1bc18c6-cff5-4553-9732-2d987efc02b7)

按照下图编写蓝图逻辑.

![Image](https://github.com/user-attachments/assets/890878cf-9657-46fc-9871-2963a97a7435)

你可能会好奇为什么每次都要循环查找本地玩家, 这么做的原因是确保当前不处在加载阶段, 并且许多涉及到玩家的变量需要获取有效的玩家数据.
创建一个自定义事件, 随意命名. 你可以从左边事件拖出, 连接在前面的节点后执行, 并启用 Tick.

![Image](https://github.com/user-attachments/assets/4a10e92b-7fb1-4178-ac2d-0d54b0369caa)

在主要事件中, 使用序列节点, 先从路径加载存档, 路径可参考下图.

![Image](https://github.com/user-attachments/assets/7240e998-6e21-4ae8-8bb7-dfb2fcee4471)

判断有效性后 Cast 到存档蓝图, 若成功则设为变量, 无效或失败则创建对应存档.

![Image](https://github.com/user-attachments/assets/ae8975e8-cb2a-40c9-8e6f-4b8492d70b19)

之后创建设置界面 Widget.

![Image](https://github.com/user-attachments/assets/710d404e-a78a-4ee7-880e-1eba54be2616)

切换到设置界面蓝图图表, 创建一个变量, 变量类型为刚才创建的存档蓝图, 并且勾选可编辑实例和生成时公开.

![Image](https://github.com/user-attachments/assets/4e2404be-6ca9-404a-9425-c6370034999e)

回到主蓝图, 右键刷新节点, 就会看到存档的输入, 将存档连接到输入中.

![Image](https://github.com/user-attachments/assets/faa81c8c-3024-4d51-9086-1c1924a3713f)

![Image](https://github.com/user-attachments/assets/7d1754f3-b61b-48a8-ae0d-9ab5137be55a)

继续创建计时器的小部件.

![Image](https://github.com/user-attachments/assets/935f3f49-b7cb-4890-b32e-4a88107312dc)

切换到设置界面蓝图图表, 在事件构造设置勾选框状态.
从存档读取上一次 Mod 的开关.

![Image](https://github.com/user-attachments/assets/ba93d32e-af07-4688-a212-7616fae87832)

当然每一次开关的状态也要保存到存档中.

![Image](https://github.com/user-attachments/assets/81c67975-f5b8-433b-9ba2-5228d72e026b)

![Image](https://github.com/user-attachments/assets/4f40f715-6cdb-4592-b883-6d29a439725a)

在主蓝图中, 还是从存档获取开关状态决定是否将小部件显示到画面中.

![Image](https://github.com/user-attachments/assets/f0d96272-c7d4-461a-b7b9-cd2642244991)

在设置界面蓝图里创建事件分发器, 并添加布尔值输入, 然后将事件拖到图表, 选择调用.
这里的作用是当勾选框被勾选或取消时, 通过事件分发器告诉某蓝图, 以执行某些节点.

![Image](https://github.com/user-attachments/assets/b7a0f559-7b8d-41e0-b63a-4c18d584c159)

![Image](https://github.com/user-attachments/assets/6da51b7c-0a8f-40f6-a9fb-ded7112659da)

别忘了在主蓝图中绑定这个事件.

![Image](https://github.com/user-attachments/assets/a11ec68c-f37e-449a-843b-be1339560e5c)

![Image](https://github.com/user-attachments/assets/1eda009d-66a8-4035-a3db-c9a309cae3f6)

创建一个浮点值变量, 这里命名为 Time.

![Image](https://github.com/user-attachments/assets/525c7471-f493-4c73-96ad-7662d217a966)

在 Tick 事件中每帧对前一帧间隔相加, 就能得到累计的时间.

![Image](https://github.com/user-attachments/assets/e1836081-805e-4a2c-81db-6238b5c78b23)

再创建一个字符串变量, 并按下图对时间做简单的计算, 通过合并节点, 即可得到标准时间格式.

![Image](https://github.com/user-attachments/assets/a161b35f-4736-4483-9d19-8d407047a404)

然后设置小部件显示的文字.

![Image](https://github.com/user-attachments/assets/effe97dc-fd32-4f4e-8f33-3a1df94454c0)

到这里主要的逻辑就写好了, 但还有一些小设置需要做, 那就是将 Mod 设置界面绑定到 ModHub 中.
先在设置界面蓝图图表上方点击类设置, 在左侧面板添加 IHub Page Widget 接口.

![Image](https://github.com/user-attachments/assets/47c6032b-014d-4578-bc59-fe2a66217543)

在接口里双击第一个函数, 页面的名称根据自己情况填写.

![Image](https://github.com/user-attachments/assets/807cee4f-3e30-4ad3-90ef-6b57c701f6a8)

![Image](https://github.com/user-attachments/assets/571ffd4e-183f-460b-a362-0f7853d4ad2c)

接着回到主蓝图, 同样需要添加接口, 选择 IHub Mod.

![Image](https://github.com/user-attachments/assets/6ce3dfe1-1876-47c4-a0ee-0f3e7505666c)

按下图设置信息.

![Image](https://github.com/user-attachments/assets/3a4c371a-5c85-4517-9e86-80907a38d71f)

![Image](https://github.com/user-attachments/assets/4e5a0518-5db2-4a51-8ced-7840eb662c2b)

注意, 如果设置界面UI无法连接到 Hub Pages, 请检查设置界面蓝图是否正确添加接口.
最后在主蓝图设置保存逻辑.
ModHub 关闭事件需要从左边接口的事件中右键选择实现事件得到.

![Image](https://github.com/user-attachments/assets/2bf5f4f6-37f9-4b2b-9db1-d5588feeca08)

![Image](https://github.com/user-attachments/assets/259271ff-20f5-4a21-9eb1-c2d3a9c30f86)

至此整个 Mod 就完成了, 这里我只需要在洞穴加载.

![Image](https://github.com/user-attachments/assets/bfb7d7f7-38f8-4d84-ad74-2aef3ffc469e)

打包方法与前一张相同, 不再赘述, 最后到游戏里看看效果吧.

![Image](https://github.com/user-attachments/assets/68cdaf71-cbe6-4c29-8d7c-04ee55d5bf91)

![Image](https://github.com/user-attachments/assets/39751c30-72d3-4960-931e-6847a8c0e5a1)

最后, 你的 Mod 存档会在这里.

![Image](https://github.com/user-attachments/assets/c84920c6-4961-4392-8ba8-274eea39eaf5)。</description><guid isPermaLink="true">https://HatsuEcho.github.io/post/%5BDRG%20BP%20Modding%5D%20-san-.%20-zhi-zuo-yi-ge-ren-wu-ji-shi-qi.html</guid><pubDate>Tue, 12 Aug 2025 04:40:48 +0000</pubDate></item><item><title>[DRG BP Modding] 二. 制作你的第一个蓝图 Mod</title><link>https://HatsuEcho.github.io/post/%5BDRG%20BP%20Modding%5D%20-er-.%20-zhi-zuo-ni-de-di-yi-ge-lan-tu-%20Mod.html</link><description>按照上一章节的指引完成设置后, 双击 FSD-Template 文件夹下的 FSD.uproject 以打开引擎项目.

![Image](https://github.com/user-attachments/assets/727ca486-c7bb-48db-8de2-bbca26311cf1)

首次打开虚幻引擎, 界面应该与图中样式保持一致.

![Image](https://github.com/user-attachments/assets/5c1c31f5-a9ba-483d-823e-5497b8a9eea4)

现在正式开始制作第一个蓝图 Mod , 先来一个简单的角色闪现.
确保当前处于 Content (内容) 文件夹下, 右键新建文件夹.

![Image](https://github.com/user-attachments/assets/5a6e5431-27ca-4453-9868-f624d690fde5)

命名最好使用自己的 ID , 比如我会使用 '_HatsuEcho', 以避免与其他 Mod 路径重合.

![Image](https://github.com/user-attachments/assets/e8016cc5-3180-4aed-8444-4b62c68d0f37)

在该文件夹下继续创建单独 Mod 的文件夹, 我们想做闪现 Mod, 就可以命名为 '_Teleport'.

![Image](https://github.com/user-attachments/assets/f72d45a0-dd6a-4d8e-91d4-71aeb89f1ae0)

在 _Teleport 文件夹下, 右键创建蓝图类.

![Image](https://github.com/user-attachments/assets/d0ca11fc-5a11-4da8-a54d-b7e6133b82b6)

类选择 Actor.

![Image](https://github.com/user-attachments/assets/b1d97e80-1183-4c5d-bea5-bb54ecf21edd)

填写 Mod 的名称.

![Image](https://github.com/user-attachments/assets/64e64fb7-68ec-4027-ae3f-0b92621b0a2e)

然后双击打开 Actor.

![Image](https://github.com/user-attachments/assets/81d0bfe8-728e-4637-b0f2-ec5ec6557e7a)

点击上方类默认值, 在右侧细节面板中把可被伤害选项取消勾选.

![Image](https://github.com/user-attachments/assets/23f5a597-fcfe-44c6-86d6-2b6d4dd7f47b)

点击事件图表选项页.

![Image](https://github.com/user-attachments/assets/0157c549-0d1a-4cb0-b005-d4298a7198c5)

引擎默认生成了三个事件节点, 我们只需要用到第一个 'Event BeginPlay' 事件, 所以可以把其余两个删掉, 左键框选节点, 按下 Delete 键即可删除.
按住右键拖动可以移动视图.
在空白区单击右键打开节点窗口, 输入 'Get Local Player Character', 选择该节点.

![Image](https://github.com/user-attachments/assets/625c28d4-8c9d-44ac-8f91-b6249b933326)

单击就会放置到图表中.

![Image](https://github.com/user-attachments/assets/49e7c513-412d-4ff4-a67d-9715f3528814)

这个节点是 DRG 游戏内的, 可以直接获取本地角色.
在 Event BeginPlay 事件后方按住左键并拖出执行引脚, 选择 Is Valid 节点.

![Image](https://github.com/user-attachments/assets/39955465-8597-4f4b-b0e1-eafa25d43bdd)

从 Get Local Player Character 节点的输出连接至 Is Valid 节点的输入中.

![Image](https://github.com/user-attachments/assets/701626a8-a739-460e-a99f-3956b48b052c)

此步骤用于检查获取的本地角色是否有效, 并且你应该包含一种解决方法来应对.
如下图所示, 在获取失败的情况下给予短暂延迟后继续尝试获取. 双击执行引脚可添加断点, 保持整洁的蓝图是良好的习惯.

![Image](https://github.com/user-attachments/assets/3dc0c52f-1032-47cf-8dc3-b5c41c782721)

我们希望通过按键操控闪现, 所以需要对 Mod 接收玩家控制器的输入.

![Image](https://github.com/user-attachments/assets/1ed8d257-5791-438e-95ba-fe6de21fa3c9)

完成后点击左上方的编译, 我强烈建议你将使用时保存设置为总是.

![Image](https://github.com/user-attachments/assets/7f2e123e-17f1-4ee4-8d32-4dc2f92d25de)

现在右键空白处输入 Key , 这里以 K 键为例.

![Image](https://github.com/user-attachments/assets/f0a981be-0e74-4e00-a27d-6b015b2a6d06)

先得到自己角色当前的位置.

![Image](https://github.com/user-attachments/assets/e340e60f-5b40-45be-ae19-673296ae49e8)

然后获取角色的旋转角度, 再得到当前视角朝向的向前向量.

![Image](https://github.com/user-attachments/assets/ab2f0df5-1b93-4bf0-af67-6cad68a71831)

![Image](https://github.com/user-attachments/assets/9aeb4496-d189-41fd-92dc-6d84ab8a255e)

将向前向量乘一个浮点值, 这个值就是你希望闪现的距离, 这里填写300, 也就是3米.

![Image](https://github.com/user-attachments/assets/e891d768-4d8c-4679-b810-21641dcfadad)

![Image](https://github.com/user-attachments/assets/14be08e8-149f-4fd3-887f-0e04a90b6e87)

然后将角色当前位置与闪现的距离相加, 这就是角色闪现之后的位置.

![Image](https://github.com/user-attachments/assets/c5b9ce15-015d-4ea4-86d7-a503404c9ab6)

![Image](https://github.com/user-attachments/assets/d1fe4e99-2ce1-4668-9350-e3cd8dbdaf9c)

然后使用 SetActorLocation 节点设置角色的位置, 并勾选 Sweep 布尔值, 防止闪现到其他物体内部.

![Image](https://github.com/user-attachments/assets/7fc7dd45-de5f-4b28-ade2-d24d749af631)

这样 Mod 的功能就完成了, 记得编译保存!

![Image](https://github.com/user-attachments/assets/34100dee-b981-4d40-b245-5b5e466e0c90)

回到文件夹里, 对该 Actor 右键创建子类蓝图, 并命名为 'InitSpacerig', 重复这个步骤, 再创建一个子类蓝图命名为 'InitCave'.
InitSpacerig = Mod 会在太空站台加载.
InitCave = Mod 会在洞穴(任务开始)内加载.
如果不希望 Mod 在洞穴内生效, 则删除 InitCave, 反之亦然.

![Image](https://github.com/user-attachments/assets/e4bc2417-553c-4910-bff0-d268f9d8aa2f)

![Image](https://github.com/user-attachments/assets/1f0afff9-2ac9-46b7-9531-4ca5b6065862)

Ctrl+Shift+S 保存所有内容.
然后就可以打包你的 Mod 了.

![Image](https://github.com/user-attachments/assets/ee0ae001-2513-4528-bba3-677d90d558c8)

打包路径可以在任意地方, 我通常选择 FSD-Template 文件夹下.

![Image](https://github.com/user-attachments/assets/c1136e14-78a7-484e-9b33-6eb6fd7da48e)

然后引擎会开始编译, 首次编译会花费较长时间, 请耐心等待编译完成, 如遇到编译错误, 你需要点击显示输出日志, 检查所有 Error 信息并寻找解决办法.

![Image](https://github.com/user-attachments/assets/11900aa8-d018-45a4-9037-b1447d5020a6)

打包完成后, 将 DRGPacker.zip 解压, 你应该得到这些文件.

![Image](https://github.com/user-attachments/assets/c67a8d70-6671-46eb-b181-96f9d71a7150)

回到引擎打包路径, 找到 WindowsNoEditor\FSD 下的 Content 文件夹, 确保该文件夹内只含有你 Mod 的内容.

![Image](https://github.com/user-attachments/assets/6661fcf6-a887-4491-b9a4-2a0e28762fcc)

然后将 Content 复制到 DRGPacker 下的 Input_P 文件夹内.

![Image](https://github.com/user-attachments/assets/95723e55-3e79-4c37-92b4-4ba0113c3556)

左键单击并拖动 Input_P 文件夹到 _Repack 上, 生成的 .pak 就是你的 Mod 成品.

![Image](https://github.com/user-attachments/assets/1f55d01e-94ae-49ab-bece-aea22a113333)

![Image](https://github.com/user-attachments/assets/116566d3-e95c-4c83-bcba-4aaae1676fe5)

需要注意的是, 蓝图 Mod 需要放入 Mod 管理器或通过 Modio 订阅才能正常在游戏内加载.。</description><guid isPermaLink="true">https://HatsuEcho.github.io/post/%5BDRG%20BP%20Modding%5D%20-er-.%20-zhi-zuo-ni-de-di-yi-ge-lan-tu-%20Mod.html</guid><pubDate>Mon, 11 Aug 2025 05:43:11 +0000</pubDate></item><item><title>[DRG BP Modding] 一. 基本工具</title><link>https://HatsuEcho.github.io/post/%5BDRG%20BP%20Modding%5D%20-yi-.%20-ji-ben-gong-ju.html</link><description># 基础工具下载
在开始制作你的 Mod 之前, 你需要先准备以下几种工具:
- [Unreal Engine 4.27](https://www.unrealengine.com/zh-CN/download)
- [DRGPacker](https://raw.githubusercontent.com/DRG-Modding/tools/main/loose-files/DRGPacker4.27.zip)
- [FSD-Template](https://github.com/DRG-Modding/FSD-Template/archive/refs/heads/main.zip)
- [DRG Community Modkit Project](https://drive.google.com/file/d/1fHSIPI14A9GJhrFsSjlh8e2t06AECYAO/view?usp=sharing)
- [Visual Studio Community](https://visualstudio.microsoft.com/zh-hans/free-developer-offers/)

---
# 基础设置
## Unreal Engine
打开 Epic 启动器, 选择虚幻引擎, 点击库.

![Image](https://github.com/user-attachments/assets/49debe2e-5f38-4b65-8621-3bfa5e4341cf)

点击图中+号, 添加引擎版本.

![Image](https://github.com/user-attachments/assets/81ff216a-acf3-488b-b342-7607d2734bcf)

选择4.27版本.

![Image](https://github.com/user-attachments/assets/33d4ef71-8a9f-425c-82e2-695e8a41362a)

点击图中选项.

![Image](https://github.com/user-attachments/assets/46bf0b53-7929-499d-9087-a698dd6576d7)

把除核心组件以外所有选项取消勾选, 我们不需要这些.

![Image](https://github.com/user-attachments/assets/193abd27-9f9b-4a5d-9d19-882bfefd9685)

然后正常安装即可.

---
## FSD-Template
把下载好的 FSD-Template.zip 和 DRG Community Modkit Project.zip 解压, 将 DRG Community Modkit Project 下的 Content 文件夹转移到 FSD-Template 文件夹下.

![Image](https://github.com/user-attachments/assets/7b0169cb-b265-4909-ba42-bdba262be66d)

确保文件结构如图所示.

---
## Visual Studio Community
打开安装包, 在工作负荷中, 勾选以下三种开发环境.

![Image](https://github.com/user-attachments/assets/a86fa752-4d4a-4bb9-9685-938a68afbaec)

在单个组件中, 勾选以下组件.

![Image](https://github.com/user-attachments/assets/b39ef855-d348-4406-b9e4-1be4dff95261)

然后安装.
至此, 准备工作完成.。</description><guid isPermaLink="true">https://HatsuEcho.github.io/post/%5BDRG%20BP%20Modding%5D%20-yi-.%20-ji-ben-gong-ju.html</guid><pubDate>Sun, 10 Aug 2025 14:19:05 +0000</pubDate></item></channel></rss>